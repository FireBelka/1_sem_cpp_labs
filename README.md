*0_0.* 
Дано бинарное поисковое дерево, в котором ключи вершин являются целыми числами в диапазоне от −231 до 231 − 1 включительно. Найдите сумму ключей всех вершин дерева.

Формат входных данных:

Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке. 
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется. 

Формат выходных данных:

Выведите единственное число — сумму ключей в построенном дереве.

*0_1.* 
По набору ключей постройте бинарное поисковое дерево и выполните его прямой левый обход.

Формат входных данных:

Входной файл содержит последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке.
В поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

Формат выходных данных:

Выходной файл должен содержать последовательность ключей вершин, полученную прямым левым обходом дерева.

*0_2* 
По набору ключей постройте бинарное поисковое дерево. Удалите из него ключ (правым удалением), если он есть в дереве. Выполните прямой левый обход полученного дерева.

Формат входных данных:

В первой строке записано целое число — ключ, который нужно удалить из дерева.
Вторая строка пустая.

Последующие строки содержат последовательность чисел — ключи вершин в порядке добавления в дерево. Ключи задаются в формате по одному в строке. Дерево содержит хотя бы две вершины.

Напомним, что в поисковом дереве все ключи по определению уникальны, поэтому при попытке добавить в дерево ключ, который там уже есть, он игнорируется.

Формат выходных данных:

Выведите последовательность ключей вершин, полученную прямым левым обходом дерева.

*0_3* 
Задано бинарное дерево. Необходимо проверить, является ли оно поисковым.
Будем предполагать, что в бинарном поисковом дереве могут быть вершины с одинаковыми ключами. Тогда, для того, чтобы дерево было поисковым, должно выполняться следующее требование: для каждой вершины xx все ключи в левом поддереве вершины x меньше ключа вершины x, а все ключи в правом поддереве больше либо равны ключу вершины x.
Формат входных данных:

Первая строка входного файла содержит единственное целое число n (1 < n < 8 * 10^5) – количество вершин в дереве.
Следующая строка содержит одно целое число m (-2^{31} < m<2^{31} - 1)– значение в корневой вершине дерева.
В каждой из последующих n−1 строк через пробелы перечисляются три параметра m, p и c, которые задают какую-либо вершину дерева.
m – целое число (-2^{31} < m < 2^{31} - 1), значение, записанное в вершине.
p – целое число (1 < p <n-1 ), номер строки входного файла, в которой был задан родитель текущей вершины (нумерация строк с нуля). Гарантируется, что p меньше, чем номер текущей строки.
c может принимать одно из двух значений `L` или `R`. Значение `L` указывает на то, что текущая вершина присоединена к родительской слева, `R` – справа.
Гарантируется, что совокупность всех строк задает корректное бинарное дерево.
Формат выходных данных
В единственной строке выведите `YES`, если заданное дерево является бинарным деревом поиска, и `NO` в противном случае.

`BinSearch` 
Необходимо реализовать бинарный поиск на отсортированном в неубывающем порядке массиве чисел.
Использование готовых функций бинарного поиска из стандартных библиотек запрещается.

Формат входных данных:

В первой строке записано число n (0<n≤3⋅10^5) — длина массива чисел. Во второй строке записано nn чисел через пробел.
В третьей строке записано число k (0<k≤3⋅10^5) запросов. В четвертой строке записано k чисел-запросов, разделённых пробелом.

Формат выходных данных:

Для каждого числа-запроса x в отдельной строке выведите через пробел числа b, l и r, где b равно 1, если x присутствует в массиве, и 0 в противном случае, l — индекс первого элемента, большего либо равного x, r — индекс первого элемента, большего x.
